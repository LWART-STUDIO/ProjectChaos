// Parts of this shader are largely based on MiniEngine shader, with some modifications. The copyright of said shader is as follow:
//
// Copyright (c) Microsoft. All rights reserved.
// This code is licensed under the MIT License (MIT).
// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
// Developed by Minigraph
//
// Author:  James Stanard
//

#pragma kernel DenoiseOcclusion_A DenoiseOcclusion=DenoiseOcclusion_A BLEND_WITH_HIGHER_RESOLUTION
#pragma kernel DenoiseOcclusion_B DenoiseOcclusion=DenoiseOcclusion_B

#include "../Headers/HMain.hlsl"
#include "../Headers/HSpaceTransforms.hlsl"

float _StepSize;
float _BlurTolerance;
float _UpsampleTolerance;
float _NoiseFilterStrength;

uint _PassNumber;

H_TEXTURE(_DepthPyramid);
H_TEXTURE(_OcclusionHighRes);
H_TEXTURE(_OcclusionLowRes);
H_RW_TEXTURE(float, _Occlusion_Output);

groupshared float DepthLDS[256];
groupshared float OcclusionLDS1[256];
groupshared float OcclusionLDS2[256];


// ------------------------ DENOISER FUNCTIONS -------------------------
void PrefetchData(uint index, int2 pixCoord)
{
    float2 InvLowResolution = 1 / (_ScreenSize.xy / pow(2, _PassNumber + 1));
    float2 pixCoordNDC = float2(pixCoord.xy) * InvLowResolution.xy;
    
    float4 Occlusion = H_GATHER_RED(_OcclusionLowRes, H_SAMPLER_POINT_CLAMP, pixCoordNDC * HRenderScale.xy, 0);
    OcclusionLDS1[index + 0 ] = Occlusion.w;
    OcclusionLDS1[index + 1 ] = Occlusion.z;
    OcclusionLDS1[index + 16] = Occlusion.x;
    OcclusionLDS1[index + 17] = Occlusion.y;
    
    int2 MaxRes = _ScreenSize.xy / pow(2, _PassNumber + 1) - 1;
    DepthLDS[index + 0 ] = 1.0 / H_LOAD_LOD(_DepthPyramid, clamp(pixCoord - int2(1, 1), int2(0, 0), MaxRes), _PassNumber).x;
    DepthLDS[index + 1 ] = 1.0 / H_LOAD_LOD(_DepthPyramid, clamp(pixCoord - int2(0, 1), int2(0, 0), MaxRes), _PassNumber).x;
    DepthLDS[index + 16] = 1.0 / H_LOAD_LOD(_DepthPyramid, clamp(pixCoord - int2(1, 0), int2(0, 0), MaxRes), _PassNumber).x;
    DepthLDS[index + 17] = 1.0 / H_LOAD_LOD(_DepthPyramid, clamp(pixCoord - int2(0, 0), int2(0, 0), MaxRes), _PassNumber).x;

    GroupMemoryBarrierWithGroupSync();
}

float SmartBlur(float a, float b, float c, float d, float e, bool Left, bool Middle, bool Right)
{
    b = Left | Middle ? b : c;
    a = Left ? a : b;
    d = Right | Middle ? d : c;
    e = Right ? e : d;
    return ((a + e) / 2.0 + b + c + d) / 4.0;
}

bool CompareDeltas(float d1, float d2, float l1, float l2)
{
    float Temp = d1 * d2 + _StepSize;
    return Temp * Temp > l1 * l2 * _BlurTolerance;
}

void BlurHorizontally(uint Index)
{
    float a0 = OcclusionLDS1[Index + 0];
    float a1 = OcclusionLDS1[Index + 1];
    float a2 = OcclusionLDS1[Index + 2];
    float a3 = OcclusionLDS1[Index + 3];
    float a4 = OcclusionLDS1[Index + 4];
    float a5 = OcclusionLDS1[Index + 5];
    float a6 = OcclusionLDS1[Index + 6];

    float d0 = DepthLDS[Index + 0];
    float d1 = DepthLDS[Index + 1];
    float d2 = DepthLDS[Index + 2];
    float d3 = DepthLDS[Index + 3];
    float d4 = DepthLDS[Index + 4];
    float d5 = DepthLDS[Index + 5];
    float d6 = DepthLDS[Index + 6];

    float d01 = d1 - d0;
    float d12 = d2 - d1;
    float d23 = d3 - d2;
    float d34 = d4 - d3;
    float d45 = d5 - d4;
    float d56 = d6 - d5;

    float l01 = d01 * d01 + _StepSize;
    float l12 = d12 * d12 + _StepSize;
    float l23 = d23 * d23 + _StepSize;
    float l34 = d34 * d34 + _StepSize;
    float l45 = d45 * d45 + _StepSize;
    float l56 = d56 * d56 + _StepSize;

    bool c02 = CompareDeltas(d01, d12, l01, l12);
    bool c13 = CompareDeltas(d12, d23, l12, l23);
    bool c24 = CompareDeltas(d23, d34, l23, l34);
    bool c35 = CompareDeltas(d34, d45, l34, l45);
    bool c46 = CompareDeltas(d45, d56, l45, l56);

    OcclusionLDS2[Index + 0] = SmartBlur(a0, a1, a2, a3, a4, c02, c13, c24);
    OcclusionLDS2[Index + 1] = SmartBlur(a1, a2, a3, a4, a5, c13, c24, c35);
    OcclusionLDS2[Index + 2] = SmartBlur(a2, a3, a4, a5, a6, c24, c35, c46);
}

void BlurVertically(uint Index)
{
    float a0 = OcclusionLDS2[Index +  0];
    float a1 = OcclusionLDS2[Index + 16];
    float a2 = OcclusionLDS2[Index + 32];
    float a3 = OcclusionLDS2[Index + 48];
    float a4 = OcclusionLDS2[Index + 64];
    float a5 = OcclusionLDS2[Index + 80];

    float d0 = DepthLDS[Index +  2];
    float d1 = DepthLDS[Index + 18];
    float d2 = DepthLDS[Index + 34];
    float d3 = DepthLDS[Index + 50];
    float d4 = DepthLDS[Index + 66];
    float d5 = DepthLDS[Index + 82];

    float d01 = d1 - d0;
    float d12 = d2 - d1;
    float d23 = d3 - d2;
    float d34 = d4 - d3;
    float d45 = d5 - d4;

    float l01 = d01 * d01 + _StepSize;
    float l12 = d12 * d12 + _StepSize;
    float l23 = d23 * d23 + _StepSize;
    float l34 = d34 * d34 + _StepSize;
    float l45 = d45 * d45 + _StepSize;

    bool c02 = CompareDeltas(d01, d12, l01, l12);
    bool c13 = CompareDeltas(d12, d23, l12, l23);
    bool c24 = CompareDeltas(d23, d34, l23, l34);
    bool c35 = CompareDeltas(d34, d45, l34, l45);

    float OcclusionFiltered0 = SmartBlur(a0, a1, a2, a3, a4, c02, c13, c24);
    float OcclusionFiltered1 = SmartBlur(a1, a2, a3, a4, a5, c13, c24, c35);

    OcclusionLDS1[Index +  0] = OcclusionFiltered0;
    OcclusionLDS1[Index + 16] = OcclusionFiltered1;
}


float BilateralUpsample(float HighResDepth, float HighResOcclusion, float4 LowResDepth, float4 LowResOcclusion)
{
    float4 Weights = float4(9, 3, 1, 3) / (abs(HighResDepth - LowResDepth) + _UpsampleTolerance);
    float TotalWeight = dot(Weights, 1) + _NoiseFilterStrength;
    float WeightedSum = dot(LowResOcclusion, Weights) + _NoiseFilterStrength;
    return HighResOcclusion * WeightedSum / TotalWeight;
}


// ------------------------ DENOISER + UPSAMPLER -------------------------
[numthreads(8, 8, 1)]
void DenoiseOcclusion(uint3 pixCoord : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint groupID : SV_GroupID)
{
    
    // Load 4 pixels per thread into LDS to fill the 16x16 LDS cache with depth and AO
    PrefetchData(groupThreadID.x << 1 | groupThreadID.y << 5, int2(pixCoord.xy + groupThreadID.xy - 2));
    
    // Horizontally blur the pixels. 13x13 -> 9x13
    if (groupIndex < 39) BlurHorizontally((groupIndex / 3) * 16 + (groupIndex % 3) * 3);
    GroupMemoryBarrierWithGroupSync();
  
    // Vertically blur the pixels. 9x13 -> 9x9
    if (groupIndex < 45) BlurVertically((groupIndex / 9) * 32 + groupIndex % 9);
    GroupMemoryBarrierWithGroupSync();
    
    // Bilateral upsample
    uint Index = groupThreadID.x + groupThreadID.y * 16;
    float4 LowResOcclusion = float4(OcclusionLDS1[Index + 16], OcclusionLDS1[Index + 17], OcclusionLDS1[Index + 1], OcclusionLDS1[Index]);
    
    #ifdef BLEND_WITH_HIGHER_RESOLUTION
    float2 InvHighResolution = 1 / (_ScreenSize.xy / pow(2, _PassNumber));
    float2 pixCoordNDC = pixCoord.xy * 2 * InvHighResolution.xy;
    float4 HighResOcclusion = H_GATHER_RED(_OcclusionHighRes, H_SAMPLER_POINT_CLAMP, pixCoordNDC * HRenderScale.xy, 0);
    #else
    float4 HighResOcclusion = 1.0;
    #endif
    
    
    float4 LowResDepth = 0;
    LowResDepth.x = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy) - int2(1,0), _PassNumber).x;
    LowResDepth.y = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy) - int2(0,0), _PassNumber).x;
    LowResDepth.z = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy) - int2(0,1), _PassNumber).x;
    LowResDepth.w = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy) - int2(1,1), _PassNumber).x;

    float4 HighResDepth = 0;
    HighResDepth.x = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy * 2) - int2(1,0), _PassNumber - 1).x;
    HighResDepth.y = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy * 2) - int2(0,0), _PassNumber - 1).x;
    HighResDepth.z = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy * 2) - int2(0,1), _PassNumber - 1).x;
    HighResDepth.w = H_LOAD_LOD(_DepthPyramid, int2(pixCoord.xy * 2) - int2(1,1), _PassNumber - 1).x;

    #ifndef BLEND_WITH_HIGHER_RESOLUTION
    HighResDepth;
    HighResDepth.x = H_LINEAR_01_DEPTH(HBUFFER_DEPTH(pixCoord.xy * 2 - int2(1,0)).x);
    HighResDepth.y = H_LINEAR_01_DEPTH(HBUFFER_DEPTH(pixCoord.xy * 2 - int2(0,0)).x);
    HighResDepth.z = H_LINEAR_01_DEPTH(HBUFFER_DEPTH(pixCoord.xy * 2 - int2(0,1)).x);
    HighResDepth.w = H_LINEAR_01_DEPTH(HBUFFER_DEPTH(pixCoord.xy * 2 - int2(1,1)).x);
    #endif
    
    int2 OutputCoord = pixCoord.xy << 1;
    _Occlusion_Output[H_COORD(OutputCoord + int2(-1,  0))] = BilateralUpsample(HighResDepth.x, HighResOcclusion.x, LowResDepth.xyzw, LowResOcclusion.xyzw);
    _Occlusion_Output[H_COORD(OutputCoord + int2( 0,  0))] = BilateralUpsample(HighResDepth.y, HighResOcclusion.y, LowResDepth.yzwx, LowResOcclusion.yzwx);
    _Occlusion_Output[H_COORD(OutputCoord + int2( 0, -1))] = BilateralUpsample(HighResDepth.z, HighResOcclusion.z, LowResDepth.zwxy, LowResOcclusion.zwxy);
    _Occlusion_Output[H_COORD(OutputCoord + int2(-1, -1))] = BilateralUpsample(HighResDepth.w, HighResOcclusion.w, LowResDepth.wxyz, LowResOcclusion.wxyz);
}
