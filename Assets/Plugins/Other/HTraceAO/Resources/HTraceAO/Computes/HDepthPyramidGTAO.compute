#pragma kernel GenerateDepthPyramid_1

#include "../Headers/HMain.hlsl"
#include "../Headers/HMath.hlsl"


H_RW_TEXTURE(float, _DepthPyramid_OutputMIP0);
H_RW_TEXTURE(float, _DepthPyramid_OutputMIP1);
H_RW_TEXTURE(float, _DepthPyramid_OutputMIP2);
H_RW_TEXTURE(float, _DepthPyramid_OutputMIP3);
H_RW_TEXTURE(float, _DepthPyramid_OutputMIP4);

groupshared float MipDepthLDS[8][8];


// ------------------------ MIP LEVEL 0-4 GENERATIONS ------------------------
[numthreads(8, 8, 1)]
void GenerateDepthPyramid_1(uint3 pixCoord : SV_DispatchThreadID, uint2 groupThreadID : SV_GroupThreadID)
{
    
    const uint2 originalCoord = pixCoord.xy;
    pixCoord *= 2;

    float4 Depth;
    Depth.x = any(pixCoord.xy + uint2(0,0) >= uint2(_ScreenSize.xy)) ? 0 : HBUFFER_DEPTH(pixCoord.xy + uint2(0,0)).x;
    Depth.y = any(pixCoord.xy + uint2(1,0) >= uint2(_ScreenSize.xy)) ? 0 : HBUFFER_DEPTH(pixCoord.xy + uint2(1,0)).x;
    Depth.z = any(pixCoord.xy + uint2(0,1) >= uint2(_ScreenSize.xy)) ? 0 : HBUFFER_DEPTH(pixCoord.xy + uint2(0,1)).x;
    Depth.w = any(pixCoord.xy + uint2(1,1) >= uint2(_ScreenSize.xy)) ? 0 : HBUFFER_DEPTH(pixCoord.xy + uint2(1,1)).x;

    Depth.x = Depth.x >= 0.9999f ? 0 : Depth.x;
    Depth.y = Depth.y >= 0.9999f ? 0 : Depth.y;
    Depth.z = Depth.z >= 0.9999f ? 0 : Depth.z;
    Depth.w = Depth.w >= 0.9999f ? 0 : Depth.w;

    // Write to MIP0
    _DepthPyramid_OutputMIP0[H_COORD(pixCoord.xy + uint2(0, 0))] = Depth.x;
    _DepthPyramid_OutputMIP0[H_COORD(pixCoord.xy + uint2(1, 0))] = Depth.y;
    _DepthPyramid_OutputMIP0[H_COORD(pixCoord.xy + uint2(0, 1))] = Depth.z;
    _DepthPyramid_OutputMIP0[H_COORD(pixCoord.xy + uint2(1, 1))] = Depth.w;

    float DepthMIP1 = max(max(Depth.x, Depth.y), max(Depth.z, Depth.w));

    // Write to MIP1
    _DepthPyramid_OutputMIP1[H_COORD(originalCoord)] = DepthMIP1;

    MipDepthLDS[groupThreadID.x][groupThreadID.y] = DepthMIP1;
    GroupMemoryBarrierWithGroupSync();
    
    // Write to MIP2
    [branch]
    if (all((groupThreadID.xy % int2(2, 2)) == 0))
    {
        float4 Depth;
        Depth.x = MipDepthLDS[groupThreadID.x + 0][groupThreadID.y + 0];
        Depth.y = MipDepthLDS[groupThreadID.x + 1][groupThreadID.y + 0];
        Depth.z = MipDepthLDS[groupThreadID.x + 0][groupThreadID.y + 1];
        Depth.w = MipDepthLDS[groupThreadID.x + 1][groupThreadID.y + 1];

        float DepthMIP2 = max(max(Depth.x, Depth.y), max(Depth.z, Depth.w));

        _DepthPyramid_OutputMIP2[H_COORD(originalCoord / 2)] = DepthMIP2;
        MipDepthLDS[groupThreadID.x][groupThreadID.y] = DepthMIP2;
    }

    GroupMemoryBarrierWithGroupSync();

    // Write to MIP3
    [branch]
    if (all((groupThreadID.xy % int2(4, 4)) == 0))
    {
        float4 Depth;
        Depth.x = MipDepthLDS[groupThreadID.x + 0][groupThreadID.y + 0];
        Depth.y = MipDepthLDS[groupThreadID.x + 2][groupThreadID.y + 0];
        Depth.z = MipDepthLDS[groupThreadID.x + 0][groupThreadID.y + 2];
        Depth.w = MipDepthLDS[groupThreadID.x + 2][groupThreadID.y + 2];

        float DepthMIP3 = max(max(Depth.x, Depth.y), max(Depth.z, Depth.w));

        _DepthPyramid_OutputMIP3[H_COORD(originalCoord / 4)] = DepthMIP3;
        MipDepthLDS[groupThreadID.x][groupThreadID.y] = DepthMIP3;
    }

    GroupMemoryBarrierWithGroupSync();

    // Write to MIP4
    [branch]
    if (all((groupThreadID.xy % int2(8, 8)) == 0))
    {
        float4 Depth;
        Depth.x = MipDepthLDS[groupThreadID.x + 0][groupThreadID.y + 0];
        Depth.y = MipDepthLDS[groupThreadID.x + 4][groupThreadID.y + 0];
        Depth.z = MipDepthLDS[groupThreadID.x + 0][groupThreadID.y + 4];
        Depth.w = MipDepthLDS[groupThreadID.x + 4][groupThreadID.y + 4];
        
        float DepthMIP4 = max(max(Depth.x, Depth.y), max(Depth.z, Depth.w));
        
        _DepthPyramid_OutputMIP4[H_COORD(originalCoord / 8)] = DepthMIP4;
    }
}
