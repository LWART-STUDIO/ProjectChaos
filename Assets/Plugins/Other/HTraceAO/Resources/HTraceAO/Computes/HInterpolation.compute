#pragma kernel Interpolation

#pragma multi_compile INTERPOLATION_LINEAR_5 INTERPOLATION_LINEAR_9 INTERPOLATION_LANCZOS_12
#pragma multi_compile _ FINAL_OUTPUT_ONLY
#pragma multi_compile _ VR_COMPATIBILITY
#pragma multi_compile _ NORMAL_REJECTION

#include "Common.hlsl"
#include "../Headers/HMain.hlsl"
#include "../Headers/HSpaceTransforms.hlsl"
#pragma multi_compile _ _GBUFFER_NORMALS_OCT

#ifdef INTERPOLATION_LINEAR_5
#define INTERPOLATION_SAMPLECOUNT 5
#else
#define INTERPOLATION_SAMPLECOUNT 9
#endif

float _Intensity;
float4 _DepthToViewParams;

H_TEXTURE(_Occlusion);
H_RW_TEXTURE(float, _Occlusion_Output);


// ------------------------ INTERPOLATION STRUCTS -----------------------
struct CenterPixelData
{
    float4  Plane;
    float3  Normal;
    float   DepthLinear;
};


// ------------------------ LANCZOS-SPECIFIC FUNCTIONS -------------------------
float2 ProcessSample(float2 Offset, float4 DirectionLength, float2 LobeClip, float2 OcclusionSample)
{
    float2 RotatedOffset = float2(dot(Offset, DirectionLength.xy), dot(Offset, float2(-DirectionLength.y, DirectionLength.x))) * DirectionLength.zw;
    float DistanceDouble = min(dot(RotatedOffset, RotatedOffset), LobeClip.y);

    float Window = 0.4 * DistanceDouble - 1.0;
    float Base = LobeClip.x * DistanceDouble - 1.0;
    Window *= Window;
    Base *= Base;
    Window = 1.5625 * Window - 0.5625;
    float Weight = Window * Base * OcclusionSample.y;

    float2 AccumulatedData;
    AccumulatedData.x = OcclusionSample.x * Weight;
    AccumulatedData.y = Weight;

    return AccumulatedData;
}


void GatherData(inout float2 Direction, inout float Length, float Weight, float2 SampleA, float2 SampleB, float2 SampleC, float2 SampleD, float2 SampleE)
{
    SampleA.x *= SampleA.y;
    SampleB.x *= SampleB.y;
    SampleC.x *= SampleC.y;
    SampleD.x *= SampleD.y;
    SampleE.x *= SampleE.y;
    
    float LengthX = max(abs(SampleD.x - SampleC.x), abs(SampleC.x - SampleB.x));
    float DirectionX = SampleD.x - SampleB.x;
    Direction.x += DirectionX * Weight;
    LengthX = clamp(abs(DirectionX)/ LengthX, 0.0, 1.0);
    LengthX *= LengthX;
    Length += LengthX * Weight;

    float LengthY = max(abs(SampleE.x - SampleC.x), abs(SampleC.x - SampleA.x));
    float DirectionY = SampleE.x - SampleA.x;
    Direction.y += DirectionY * Weight;
    LengthY = clamp(abs(DirectionY) / LengthY, 0.0, 1.0);
    LengthY *= LengthY;
    Length += LengthY * Weight;
}


void AdaptiveLanczosData(float2 Samples[12], float2 PixelCoord, inout float4 DirLength, inout float2 LobeClip)
{
    float Length = 0;
    float2 Direction = 0;
    GatherData(Direction, Length, (1.0 -PixelCoord.x) * (1.0 -PixelCoord.y), Samples[0], Samples[5], Samples[4], Samples[9], Samples[3]);
    GatherData(Direction, Length, PixelCoord.x * (1.0 -PixelCoord.y), Samples[1], Samples[4], Samples[9], Samples[8], Samples[6]);
    GatherData(Direction, Length, (1.0 -PixelCoord.x) * PixelCoord.y, Samples[4], Samples[2], Samples[3], Samples[6], Samples[11]);
    GatherData(Direction, Length, PixelCoord.x * PixelCoord.y, Samples[9], Samples[3], Samples[6], Samples[7], Samples[10]);
    
    float2 DirectionDouble = Direction * Direction;
    float DirectionRadial = DirectionDouble.x + DirectionDouble.y;
    bool IsNearZero = DirectionRadial < (1.0 / 32768.0);
    DirectionRadial = rsqrt(DirectionRadial);
    DirectionRadial = IsNearZero ? 1.0 : DirectionRadial;
    Direction.x = IsNearZero ? 1.0 : Direction.x;
    Direction *= float2(DirectionRadial, DirectionRadial);
    Length = Length * 0.5;
    Length *= Length;
    
    float Stretch = dot(Direction,Direction) / (max(abs(Direction.x), abs(Direction.y)));
    float2 LengthDouble = float2(1.0 + (Stretch -1.0) * Length, 1.0 - 0.5 * Length);
    float NegativeLobe = 0.5 - 0.29 * Length;
    float Clip = 1.0 / NegativeLobe;
    
    DirLength = float4(Direction.xy, LengthDouble.xy);
    LobeClip = float2(NegativeLobe, Clip);
}


// ------------------------ INTERPOLATION FUNCTIONS -------------------------
float3 ComputeViewSpacePosition(float2 pixCoordNDC, float Depth, float DepthLinear)
{
    #ifdef VR_COMPATIBILITY
    return ComputeViewSpacePosition(pixCoordNDC, Depth, UNITY_MATRIX_I_P) * float3(1, -1, 1);
    #endif
    
    float3 PositionVS = float3((pixCoordNDC * _DepthToViewParams.xy + _DepthToViewParams.zw) * DepthLinear, DepthLinear);
    return PositionVS * float3(1, 1, -1);
}


float2 InterpolationSample(CenterPixelData CenterData, int2 SampleCoord)
{
    float DepthSample, OcclusionSample; float3 NormalSample;
    uint SampleDataPacked = asuint(H_LOAD(_Occlusion, SampleCoord).x);
    UnpackSpatialData(SampleDataPacked, OcclusionSample, DepthSample, NormalSample);

    float3 WorldPos = ComputeViewSpacePosition((SampleCoord * 2.0f + 0.5) / _ScreenSize.xy, DepthSample, H_LINEAR_EYE_DEPTH(DepthSample));
    float PlaneWeight = ProbePlaneWeighting(CenterData.Plane, WorldPos, CenterData.DepthLinear, 5000);
    float NormalWeight = 1;

    if (NORMAL_REJECTION)
    NormalWeight = saturate(dot(CenterData.Normal, NormalSample));
    
    return float2(OcclusionSample, PlaneWeight * NormalWeight);
}


// ------------------------ INTERPOLATION -------------------------
[numthreads(8, 8, 1)]
void Interpolation(uint3 pixCoord : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint groupID : SV_GroupID)
{
    
    if (FINAL_OUTPUT_ONLY)
    {
        uint OcclusionPacked = asuint(H_LOAD(_Occlusion, pixCoord.xy / _HScaleFactorAO).x);
        float Occlusion = UnpackOcclusion(OcclusionPacked);
        
        _Occlusion_Output[H_COORD(pixCoord.xy)] = pow(Occlusion, _Intensity);
        return;
    }
    
    const float DepthCenter = HBUFFER_DEPTH(pixCoord.xy).x;
    const float3 NormalCenterWS = HBUFFER_NORMAL_WS(pixCoord.xy).xyz;
    const float3 NormalCenterVS = H_TRANSFORM_WORLD_TO_VIEW_NORMAL(NormalCenterWS);
    const float3 WorldPosCenter = ComputeViewSpacePosition((pixCoord.xy + 0.5f) * _ScreenSize.zw, DepthCenter, H_LINEAR_EYE_DEPTH(DepthCenter));
    const int2 SampleOffsets[9] = {int2(0, 0), int2(1, 0), int2(0, 1), int2(-1, 0), int2(0, -1), int2(1, -1), int2(-1, 1), int2(-1, -1), int2(1, 1)};
    
    CenterPixelData CenterData;
    CenterData.Normal = NormalCenterWS;
    CenterData.Plane = float4(NormalCenterVS, dot(WorldPosCenter, NormalCenterVS));
    CenterData.DepthLinear = H_LINEAR_EYE_DEPTH(DepthCenter);

    float InterpolatedOcclusion = 0;
    
    if (INTERPOLATION_LANCZOS_12)
    {
        float2 LanczosOffset = float2(pixCoord.xy) * 0.5f - 0.25f; LanczosOffset -= floor(LanczosOffset);   // 0.25 or 0.75
        int2 LanczosOffsetRounded = -round(LanczosOffset);                                                  // -1 or 0;
        
        float2 Samples[12];
        Samples[0]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 0,-1) + LanczosOffsetRounded);
        Samples[1]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 1,-1) + LanczosOffsetRounded);
        Samples[2]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2(-1, 1) + LanczosOffsetRounded);
        Samples[3]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 0, 1) + LanczosOffsetRounded);
        Samples[4]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 0, 0) + LanczosOffsetRounded);
        Samples[5]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2(-1, 0) + LanczosOffsetRounded);
        Samples[6]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 1, 1) + LanczosOffsetRounded);
        Samples[7]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 2, 1) + LanczosOffsetRounded);
        Samples[8]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 2, 0) + LanczosOffsetRounded);
        Samples[9]  = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 1, 0) + LanczosOffsetRounded);
        Samples[10] = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 1, 2) + LanczosOffsetRounded);
        Samples[11] = InterpolationSample(CenterData, pixCoord.xy / 2 + int2( 0, 2) + LanczosOffsetRounded);
        
        float4 DirLength; float2 LobeClip;
        AdaptiveLanczosData(Samples, LanczosOffset, DirLength, LobeClip);
        
        float MinNeighbourhood = min(min(Samples[4].x, Samples[9].x), min(Samples[3].x, Samples[6].x));
        float MaxNeighbourhood = max(max(Samples[4].x, Samples[9].x), max(Samples[3].x, Samples[6].x));
        
        float2 AccumulatedData = 0;
        AccumulatedData += ProcessSample(float2( 0,-1) -LanczosOffset, DirLength, LobeClip, Samples[0]);
        AccumulatedData += ProcessSample(float2( 1,-1) -LanczosOffset, DirLength, LobeClip, Samples[1]);
        AccumulatedData += ProcessSample(float2(-1, 1) -LanczosOffset, DirLength, LobeClip, Samples[2]);
        AccumulatedData += ProcessSample(float2( 0, 1) -LanczosOffset, DirLength, LobeClip, Samples[3]);
        AccumulatedData += ProcessSample(float2( 0, 0) -LanczosOffset, DirLength, LobeClip, Samples[4]);
        AccumulatedData += ProcessSample(float2(-1, 0) -LanczosOffset, DirLength, LobeClip, Samples[5]);
        AccumulatedData += ProcessSample(float2( 1, 1) -LanczosOffset, DirLength, LobeClip, Samples[6]);
        AccumulatedData += ProcessSample(float2( 2, 1) -LanczosOffset, DirLength, LobeClip, Samples[7]);
        AccumulatedData += ProcessSample(float2( 2, 0) -LanczosOffset, DirLength, LobeClip, Samples[8]);
        AccumulatedData += ProcessSample(float2( 1, 0) -LanczosOffset, DirLength, LobeClip, Samples[9]);
        AccumulatedData += ProcessSample(float2( 1, 2) -LanczosOffset, DirLength, LobeClip, Samples[10]);
        AccumulatedData += ProcessSample(float2( 0, 2) -LanczosOffset, DirLength, LobeClip, Samples[11]);
        
        AccumulatedData.y = max(AccumulatedData.y, 0.05f);
        InterpolatedOcclusion = min(MaxNeighbourhood, max(MinNeighbourhood, AccumulatedData.x / AccumulatedData.y));
    }
    else
    {
        const int2 SampleOffsets[9] = {int2(0, 0), int2(1, 0), int2(0, 1), int2(-1, 0), int2(0, -1), int2(1, -1), int2(-1, 1), int2(-1, -1), int2(1, 1)};
    
        float AccumulatedWeight = 0;
        for (int i = 0; i < INTERPOLATION_SAMPLECOUNT; i++)
        {
            int2 Offset = SampleOffsets[i];
            float2 Sample = InterpolationSample(CenterData, pixCoord.xy / 2 + Offset);
            
            Sample.y *= exp(-4.0 * float(Offset.x * Offset.x + Offset.y * Offset.y) / float(4.0f));
            InterpolatedOcclusion += Sample.x * Sample.y;
            AccumulatedWeight += Sample.y;
        }
        
        InterpolatedOcclusion = AccumulatedWeight > 0 ? InterpolatedOcclusion / AccumulatedWeight : 0.5f;
    }
    
    _Occlusion_Output[H_COORD(pixCoord.xy)] = pow(InterpolatedOcclusion, _Intensity);
}
